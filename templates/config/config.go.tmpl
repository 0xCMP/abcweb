package config

import (
	"strings"
	"fmt"
	"time"
	"errors"

	"github.com/spf13/viper"
	"github.com/spf13/pflag"
	"github.com/kat-co/vala"
)

// AppConfig is config for the app loaded through environment variables,
// command line, or the config.toml file.
type AppConfig struct {
	// The active config file environment mode
	ActiveEnv string `toml:"env" mapstructure:"env"`
	// LiveReload enabled or disabled
	LiveReload bool `toml:"live-reload" mapstructure:"live-reload"`
	// Use the production logger (JSON and log level warn) or the
	// development logger (console and log level info)
	ProdLogger bool `toml:"prod-logger" mapstructure:"prod-logger"`
	// http bind address. ":<port>" for all interfaces
	Bind string `toml:"bind" mapstructure:"bind"`
	// https bind address. ":<port>" for all interfaces
	TLSBind string `toml:"tls-bind" mapstructure:"tls-bind"`
	// TLS certificate file path
	TLSCertFile string `toml:"tls-cert-file" mapstructure:"tls-cert-file"`
	// TLS key file path
	TLSKeyFile string `toml:"tls-key-file" mapstructure:"tls-key-file"`
	// Maximum duration before timing out read of the request
	ReadTimeout time.Duration `toml:"read-timeout" mapstructure:"read-timeout"`
	// Maximum duration before timing out write of the response
	WriteTimeout time.Duration `toml:"write-timeout" mapstructure:"write-timeout"`
	// Maximum duration before timing out idle keep-alive connection
	IdleTimeout time.Duration `toml:"idle-timeout" mapstructure:"idle-timeout"`
	// Use manifest.json assets mapping
	AssetsManifest bool `toml:"assets-manifest" mapstructure:"assets-manifest"`
	// Disable browsers caching asset files by setting response headers
	AssetsNoCache bool `toml:"assets-no-cache" mapstructure:"assets-no-cache"`
	// RenderRecompile enables recompilation of the template on every render call.
	// This should be used in development mode so no server restart is required
	// on template file changes.
	RenderRecompile bool `toml:"render-recompile" mapstructure:"render-recompile"`
	{{if not .NoSessions -}}
	// Use the development mode sessions storer opposed to production mode storer
	// defined in app/sessions.go -- Usually a cookie storer for dev
	// and disk storer for prod.
	SessionsDevStorer bool `toml:"sessions-dev-storer" mapstructure:"sessions-dev-storer"`
	{{- end}}
	// PublicPath defaults to "public" but can be set to something else
	// by the {{.AppEnvName}}_PUBLIC_PATH environment variable.
	// This is set by the "abcweb dev" command to instruct the app to
	// load assets from a /tmp folder instead of the local public folder.
	PublicPath string `toml:"public-path" mapstructure:"public-path"`

	// DB holds the database config for the app loaded through
	// environment variables or the config.toml file.
	DB *DBConfig `toml:"db" mapstructure:"db"`
}

// DBConfig holds the database config for the app loaded through
// environment variables, or the config.toml file.
type DBConfig struct {
	// DB is the database software; "postgres", "mysql", etc.
	DB      string `toml:"db" mapstructure:"db"`
	// The database name
	DBName  string `toml:"dbname" mapstructure:"dbname"`
	Host    string `toml:"host" mapstructure:"host"`
	Port    int    `toml:"port" mapstructure:"port"`
	User    string `toml:"user" mapstructure:"user"`
	Pass    string `toml:"pass" mapstructure:"pass"`
	SSLMode string `toml:"sslmode" mapstructure:"sslmode"`

	// Throw an error when the app starts if the database is not
	// using the latest migration
	EnforceMigration bool `toml:"enforce-migration" mapstructure:"enforce-migration"`
}

// NewAppViper returns a viper instance activated against the active environment
// configuration subsection and initialized with the config.toml
// configuration file and the environment variable prefix.
func NewAppViper(flags *pflag.FlagSet, path string) (*viper.Viper, error) {
	v := viper.New()

	if flags != nil {
		v.BindPFlags(flags)
	}

	ConfigureViper(v, path)
	
	env := v.GetString("env")

	v = v.Sub(env)
	if v == nil {
		return nil, fmt.Errorf("unable to load environment %q from %q", env, path)
	}

	if flags != nil {
		v.BindPFlags(flags)
	}

	v.Set("env", env)
	return v, nil
}

// ConfigureViper sets the viper object to use the passed in config toml file
// and also configures the configuration environment variables.
func ConfigureViper(v *viper.Viper, path string) {
	v.SetConfigType("toml")
	v.SetConfigFile(path)
	v.SetEnvPrefix("{{.AppEnvName}}")
	v.SetEnvKeyReplacer(strings.NewReplacer("-", "_"))
	v.ReadInConfig()
	v.AutomaticEnv()
}

// LoadAppConfig loads the config.toml app configuration object
func LoadAppConfig(v *viper.Viper) *AppConfig {
	cfg := &AppConfig{}
	
	err := v.Unmarshal(cfg)
	if err != nil {
		panic(err)
	}
	
	if cfg.DB.DB == "postgres" {
		if cfg.DB.Port == 0 {
			cfg.DB.Port = 5432
		}
		if cfg.DB.SSLMode == "" {
			cfg.DB.SSLMode = "require"
		}
	} else if cfg.DB.DB == "mysql" {
		if cfg.DB.Port == 0 {
			cfg.DB.Port = 3306
		}
		if cfg.DB.SSLMode == "" {
			cfg.DB.SSLMode = "true"
		}
	}

	return cfg
}

// ValidateDBConfig returns an error if any of the required db config
// fields are not set to their appropriate values.
func ValidateDBConfig(cfg *DBConfig) error {
	if cfg.DB != "postgres" && cfg.DB != "mysql" {
		return errors.New("not a valid driver name")
	}

	return vala.BeginValidation().Validate(
		vala.StringNotEmpty(cfg.DB, "db"),
		vala.StringNotEmpty(cfg.User, "user"),
		vala.StringNotEmpty(cfg.Host, "host"),
		vala.Not(vala.Equals(cfg.Port, 0, "port")),
		vala.StringNotEmpty(cfg.DBName, "dbname"),
		vala.StringNotEmpty(cfg.SSLMode, "sslmode"),
	).Check()
}
