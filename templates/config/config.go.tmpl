package config

import (
	"os"
	"path/filepath"
	"strings"
	"fmt"
	"time"

	"github.com/spf13/viper"
	"github.com/spf13/pflag"
	"github.com/nullbio/helpers/git"
)

// AppConfig is config for the app loaded through environment variables, 
// command line, or the config.toml file.
type AppConfig struct {
	// The active config file environment mode
	ActiveEnv string
	// LiveReload enabled or disabled
	LiveReload bool
	// Use the production logger (JSON and log level warn), or the
	// development logger (console and log level info)
	ProdLogger bool
	// http bind address. ":<port>" for all interfaces
	Bind string
	// https bind address. ":<port>" for all interfaces
	TLSBind string
	// TLS certificate file path
	TLSCertFile string
	// TLS key file path
	TLSKeyFile string
	// Maximum duration before timing out read of the request
	ReadTimeout time.Duration
	// Maximum duration before timing out write of the response
	WriteTimeout time.Duration
	// Templates folder path
	Templates string
	// Static assets input folder path
	AssetsIn string
	// Compiled assets output folder path
	AssetsOut string 
	// Disable precompilation of assets
	AssetsNoCompile bool
	// Disable minification of assets
	AssetsNoMinify bool 
	// Disable fingerprints in compiled asset filenames
	AssetsNoHash bool 
	// Disable Gzip compression of asset files
	AssetsNoCompress bool 
	// Disable browsers caching asset files by setting response headers
	AssetsNoCache bool 
	// RenderRecompile enables recompilation of the template on every render call.
	// This should be used in development mode so no server restart is required
	// on template file changes.
	RenderRecompile bool 
	{{if not .NoSessions -}}
	// Use the development mode sessions storer opposed to production mode storer
	SessionsDevStorer bool 
	{{- end}}
}

// DBConfig holds the database config for the app loaded through
// environment variables, or the database.toml file.
type DBConfig struct {
	// DB is the database software; "postgres", "mysql", etc.
	DB      string
	Host    string
	Port    int
	DBName  string
	User    string
	Pass    string
	SSLMode string
}

// NewAppViper returns a viper instance activated against the active environment
// configuration subsection and initialized with the database.toml
// configuration file and the environment variable prefix.
func NewAppViper(flags *pflag.FlagSet) (*viper.Viper, error) {
	{{$envAppNm := envAppName .AppName -}}
	env := os.Getenv("{{$envAppNm}}_ENV")

	appPath, err := git.GetAppPath()
	if err != nil {
		return nil, err
	}

	v := viper.New()
	v.SetConfigType("toml")
	v.SetConfigFile(filepath.Join(appPath, "config.toml"))
	v.SetEnvPrefix("{{$envAppNm}}")
	v.SetEnvKeyReplacer(strings.NewReplacer("-", "_"))
	v.ReadInConfig()

	if env == "" {
	  env = v.GetString("env")
	}
	if env == "" {
	  fmt.Println(`Warning: No environment chosen using {{$envAppNm}}_ENV or env field in config.toml, attempting to use fallback of "prod"`)
	  env = "prod"
	}

	v = v.Sub(env)
	if v == nil {
		return nil, fmt.Errorf("unable to load environment %s from app config file", env)
	}

	v.BindPFlags(flags)

	v.Set("env", env)
	return v, nil
}

// NewDBViper returns a viper instance activated against the active environment
// configuration subsection and initialized with the database.toml
// configuration file and the environment variable prefix.
func NewDBViper(env string) (*viper.Viper, error) {
	if env == "" {
		return nil, fmt.Errorf("empty environment parameter received")
	}

	appPath, err := git.GetAppPath()
	if err != nil {
		return nil, err
	}

	cfgPath := filepath.Join(appPath, "database.toml")
	
	if _, err := os.Stat(cfgPath); os.IsNotExist(err) {
		return nil, nil
	}

	v := viper.New()
	v.SetConfigType("toml")
	v.SetConfigFile(cfgPath)
	v.SetEnvPrefix("{{$envAppNm}}")
	v.SetEnvKeyReplacer(strings.NewReplacer("-", "_"))
	v.ReadInConfig()

	v = v.Sub(env)
	if v == nil {
		return nil, fmt.Errorf("unable to load environment %s from database config file", env)
	}

	v.Set("env", env)
	return v, nil
}

// LoadAppConfig loads the config.toml app configuration object
func LoadAppConfig(v *viper.Viper) *AppConfig {
	return &AppConfig{
		ActiveEnv:			v.GetString("env"),
		LiveReload:			v.GetBool("live-reload"),
		ProdLogger:			v.GetBool("prod-logger"),
		Bind:					v.GetString("bind"),
		TLSBind:				v.GetString("tls-bind"),
		TLSCertFile:		v.GetString("tls-cert-file"),
		TLSKeyFile:			v.GetString("tls-key-file"),
		ReadTimeout:		v.GetDuration("read-timeout"),
		WriteTimeout:		v.GetDuration("write-timeout"),
		Templates:			v.GetString("templates"),
		AssetsIn:			v.GetString("assets-in"),
		AssetsOut:			v.GetString("assets-out"),
		AssetsNoCompile:	v.GetBool("assets-no-compile"),
		AssetsNoMinify:	v.GetBool("assets-no-minify"),
		AssetsNoHash:		v.GetBool("assets-no-hash"),
		AssetsNoCompress:	v.GetBool("assets-no-compress"),
		AssetsNoCache:		v.GetBool("assets-no-cache"),
		RenderRecompile:	v.GetBool("render-recompile"),
		{{if not .NoSessions -}}
		SessionsDevStorer: v.GetBool("sessions-dev-storer"),
		{{- end}}
	}
}

// LoadDBConfig loads the database.toml database configuration object
func LoadDBConfig(v *viper.Viper) *DBConfig {
	cfg := &DBConfig{
		DB:		v.GetString("db"),
		Host:		v.GetString("host"),
		Port:		v.GetInt("port"),
		DBName:	v.GetString("dbname"),
		User:		v.GetString("user"),
		Pass:		v.GetString("pass"),
		SSLMode: v.GetString("sslmode"),
	}

	if cfg.DB == "postgres" {
		if cfg.Port == 0 {
			cfg.Port = 5432
		}
		if cfg.SSLMode == "" {
			cfg.SSLMode = "require"
		}
	} else if cfg.DB == "mysql" {
		if cfg.Port == 0 {
			cfg.Port = 3306
		}
		if cfg.SSLMode == "" {
			cfg.SSLMode = "true"
		}
	}

	return cfg
}
