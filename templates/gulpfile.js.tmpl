/**
	SETUP AND INITIALIZATION
*/

var gulp = require('gulp');
var util = require('gulp-util');
var es   = require('event-stream');

var config = {
	// paths to the assets.
	paths: {
		src:  __dirname + '/assets/',
		dist: __dirname + '/dist/',
		build: {
			dev:  __dirname + '/public/assets/',
			prod: __dirname + '/dist/public/assets/'
		},
		public: {
			dev:  __dirname + '/public/',
			prod: __dirname + '/dist/public/'
		},
		migrations: {
			dev:  __dirname + '/db/migrations/',
			prod: __dirname + '/dist/migrations/'
		},
		templates: {
			dev:  __dirname + '/templates/',
			prod: __dirname + '/dist/templates/'
		}
	},

	// The manifest file holds the mappings for the fingerprinted files,
	// example: {"js/bootstrap.js": "js/bootstrap-82e1ab4c0.js"}
	manifestBase: 'public/assets',
	// app/routes.go NotFound handler loads this manifest file
	// to serve compiled assets in production mode
	manifestPath: 'public/assets/manifest.json',

	// if undefined, set to false. set production mode to true by
	// passing in --production, i.e: gulp compile --production
	{{if not .NoLiveReload -}}
	// If production is set to true then livereload.js will be ignored.
	{{- end}}
	// production is automatically set to true when running "build" task.
	production: !!util.env.production,

	// buildTarget is initialized by the setup function.
	// buildTarget is set to build.dev or build.prod depending on whether
	// the gulp build task is called, or the --production flag is present.
	// All tasks get their build output path from this variable.
	buildTarget: "",
};

// update the buildTarget if --production flag is set or build task is called.
(function setup() {
	if (config.production || process.argv.slice(2).indexOf("build") != -1) {
		// production could be false, if build task is called set to true
		config.production = true
		config.buildTarget = config.paths.build.prod
	} else {
		config.buildTarget = config.paths.build.dev
	}
})();

/**
	COMPILE AND MOVE TASKS
*/

gulp.task('compile-css', function() {
	var less    = require('gulp-less');
	var sass    = require('gulp-sass');
	var postcss = require('gulp-postcss');

	return es.merge(
		gulp.src([config.paths.src + 'css/**/*.scss', config.paths.src + 'css/**/*.sass']).pipe(sass()),
		gulp.src(config.paths.src + 'css/**/*.less').pipe(less()),
		gulp.src([config.paths.src + 'css/**/*.css', config.paths.src + 'vendor/css/**/*.css'])
	).pipe(postcss([require('autoprefixer', 'postcss-flexbug-fixes')]))
		.pipe(gulp.dest(config.buildTarget + 'css'))
});

gulp.task('compile-js', function() {
	var glob = [
		config.paths.src + 'js/**/*.js', 
		config.paths.src + 'vendor/js/**/*.js'
	]

	{{- if not .NoLiveReload}}
	// ignore specific files when in production mode
	if (config.production) {
		glob.push('!' + config.paths.src + 'vendor/js/livereload.js')
	}
	{{- end}}

	return gulp.src(glob)
		.pipe(gulp.dest(config.buildTarget + 'js'))
});

gulp.task('compile-img', function() {
	return gulp.src([config.paths.src + 'img/**/*', config.paths.src + 'vendor/img/**/*'])
		.pipe(gulp.dest(config.buildTarget + 'img'))
});

gulp.task('compile-fonts', function() {
	return gulp.src([config.paths.src + 'fonts/**/*', config.paths.src + 'vendor/fonts/**/*'])
		.pipe(gulp.dest(config.buildTarget + 'fonts'))
});

gulp.task('compile-video', function() {
	return gulp.src([config.paths.src + 'video/**/*', config.paths.src + 'vendor/video/**/*'])
		.pipe(gulp.dest(config.buildTarget + 'video'))
});

gulp.task('compile-audio', function() {
	return gulp.src([config.paths.src + 'audio/**/*', config.paths.src + 'vendor/audio/**/*'])
		.pipe(gulp.dest(config.buildTarget + 'audio'))
});

/**
	MINIFY TASKS	
*/

gulp.task('minify-css', function() {
	var minifyCSS = require('gulp-clean-css');
	return gulp.src(config.buildTarget + 'css/**/*.css')
		.pipe(minifyCSS())
		.pipe(gulp.dest(config.buildTarget + 'css'));
});

gulp.task('minify-js', function() {
	var minifyJS = require('gulp-minify');

	return gulp.src(config.buildTarget + 'js/**/*.js')
		.pipe(minifyJS({noSource: true, ext: {min: '.js'}}))
		.pipe(gulp.dest(config.buildTarget + 'js'));
});

/**
	GZIP TASK - GZIP COMPRESS ALL ASSETS INTO ACCOMPANYING .GZ FILES
*/

gulp.task('gzip', function() {
	var gzip = require('gulp-gzip');

	return gulp.src(config.buildTarget + '**/*')
		.pipe(gzip())
		.pipe(gulp.dest(config.buildTarget));
});

/**
	MANIFEST TASK - FINGERPRINT ASSETS AND GENERATE MANIFEST FILE	
*/

gulp.task('manifest', function() {
	var rev    = require('gulp-rev');
	var revdel = require('gulp-rev-delete-original');

	// Fingerprint all assets, delete old assets and then
	// create the manifest file out of the new asset filenames.
	return gulp.src(config.buildTarget + '**/*')
		.pipe(rev())
		.pipe(revdel())
		.pipe(gulp.dest(function(file) {
			return file.base
		}))
		.pipe(rev.manifest(config.manifestPath, {base: config.manifestBase}))
		.pipe(gulp.dest(config.buildTarget));
});

/**
	CLEAN TASK - CLEAN BUILD ASSETS DIRECTORY TO PREVENT LEFT-OVER FILES
*/

gulp.task('clean', function() {
	var del = require('del');

	return del([config.paths.dist])
});

/**
	COPY TASK - COPY THE NON-BUILD ASSETS FROM PUBLIC TO DIST/PUBLIC
				 - COPY THE MIGRATION FILES FROM DB/MIGRATIONS TO DIST/MIGRATIONS
*/

gulp.task('copy', function(cb) {
	// Copy over the non-build public assets
	gulp.src(config.paths.build.dev + '**/*', '!' + config.paths.build.dev)
		.pipe(gulp.dest(config.paths.public.prod))
	
	// Copy over the migrations
	gulp.src(config.paths.migrations.dev + '**/*')
		.pipe(gulp.dest(config.paths.migrations.prod))

	// Copy over the templates
	gulp.src(config.paths.templates.dev + '**/*')
		.pipe(gulp.dest(config.paths.templates.prod))
	
	cb();
});

/**
	WRAPPER TASKS
*/

// Compile task executes all compile and move tasks.
gulp.task('compile', gulp.parallel('compile-js', 'compile-css', 'compile-fonts', 'compile-img', 'compile-video', 'compile-audio'));

// Minify task executes all minify tasks.
gulp.task('minify', gulp.parallel('minify-js', 'minify-css'));

// Build task executes compile and move tasks,
// then minify tasks,
// then finally the fingerprint and manifest generation task.
gulp.task('build', gulp.series('clean', 'copy', 'compile', 'minify', 'gzip', 'manifest'));

// Default task executes all compile and move tasks.
gulp.task('default', gulp.series('compile'));

/**
	WATCH TASK
*/

// Watch task compiles all assets on start, then watches assets and html templates
{{if not .NoLiveReload -}}
// for change, recompiles them and signals livereload to reload the browser.
{{- else -}}
// for change and recompiles them.
{{- end}}
gulp.task('watch', gulp.series('compile', function() {
	var watch      = require('gulp-watch');
	var less       = require('gulp-less');
	var sass       = require('gulp-sass');
	var postcss    = require('gulp-postcss');
	var plumber    = require('gulp-plumber');
	{{if not .NoLiveReload -}}
	var livereload = require('gulp-livereload');

	livereload.listen();
	{{- end}}
	
	es.merge(
		watch([config.paths.src + 'css/**/*.scss', config.paths.src + 'css/**/*.sass'])
			.pipe(plumber())
			.pipe(sass()),
		watch(config.paths.src + 'css/**/*.less', { ignoreInitial: true })
			.pipe(plumber())
			.pipe(less()),
		watch([config.paths.src + 'css/**/*.css', config.paths.src + 'vendor/css/**/*.css'])
	).pipe(postcss([require('autoprefixer', 'postcss-flexbug-fixes')]))
		.pipe(gulp.dest(config.buildTarget + 'css'))
		{{if not .NoLiveReload -}}
		.pipe(livereload())
		{{- end}}

	watch([config.paths.src + 'js/**/*.js', config.paths.src + 'vendor/js/**/*.js'])
		.pipe(plumber())
		.pipe(gulp.dest(config.buildTarget + 'js'))
		{{if not .NoLiveReload -}}
		.pipe(livereload())
		{{- end}}

	watch([config.paths.src + 'img/**/*', config.paths.src + 'vendor/img/**/*'])
		.pipe(plumber())
		.pipe(gulp.dest(config.buildTarget + 'img'))
		{{if not .NoLiveReload -}}
		.pipe(livereload())
		{{- end}}

	watch([config.paths.src + 'fonts/**/*', config.paths.src + 'vendor/fonts/**/*'])
		.pipe(plumber())
		.pipe(gulp.dest(config.buildTarget + 'fonts'))
		{{if not .NoLiveReload -}}
		.pipe(livereload())
		{{- end}}

	watch([config.paths.src + 'video/**/*', config.paths.src + 'vendor/video/**/*'])
		.pipe(plumber())
		.pipe(gulp.dest(config.buildTarget + 'video'))
		{{if not .NoLiveReload -}}
		.pipe(livereload())
		{{- end}}

	watch([config.paths.src + 'audio/**/*', config.paths.src + 'vendor/audio/**/*'])
		.pipe(plumber())
		.pipe(gulp.dest(config.buildTarget + 'audio'))
		{{if not .NoLiveReload -}}
		.pipe(livereload())
		{{- end}}

	// Watch html templates
	return watch(config.paths.templates + '**/*')
		{{if not .NoLiveReload -}}
		.pipe(livereload())
		{{- end}}
}));
