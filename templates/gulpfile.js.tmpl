var gulp = require('gulp');
var util = require('gulp-util');
var es   = require('event-stream');

var config = {
	// paths to the assets.
	paths: {
		src: __dirname + '/assets/',
		build: __dirname + '/public/assets/',
		templates: __dirname + '/templates/**/*',
	},

	// The manifest file holds the mappings for the fingerprinted files,
	// example: {"js/bootstrap.js": "js/bootstrap-82e1ab4c0.js"}
	manifestBase: 'public/assets',
	manifestPath: 'public/assets/manifest.json',

	// set undefined value to false. set production mode to true by
	// passing in --production, i.e: gulp compile --production
	production: !!util.env.production
}

/**
	Compile and move tasks.
*/

gulp.task('compile-css', function() {
	var less    = require('gulp-less');
	var sass    = require('gulp-sass');
	var postcss = require('gulp-postcss');

	return es.merge(
		gulp.src([config.paths.src + 'css/**/*.scss', config.paths.src + 'css/**/*.sass']).pipe(sass()),
		gulp.src(config.paths.src + 'css/**/*.less').pipe(less()),
		gulp.src([config.paths.src + 'css/**/*.css', config.paths.src + 'vendor/css/**/*.css'])
	).pipe(postcss([require('autoprefixer', 'postcss-flexbug-fixes')]))
		.pipe(gulp.dest(config.paths.build + 'css'))
});

gulp.task('compile-js', function() {
	var glob = [
		config.paths.src + 'js/**/*.js', 
		config.paths.src + 'vendor/js/**/*.js'
	]

	// ignore specific files when in production mode
	if (config.production) {
		glob.push('!' + config.paths.src + 'vendor/js/livereload.js')
	}

	return gulp.src(glob)
		.pipe(gulp.dest(config.paths.build + 'js'))
});

gulp.task('compile-img', function() {
	return gulp.src([config.paths.src + 'img/**/*', config.paths.src + 'vendor/img/**/*'])
		.pipe(gulp.dest(config.paths.build + 'img'))
});

gulp.task('compile-fonts', function() {
	return gulp.src([config.paths.src + 'fonts/**/*', config.paths.src + 'vendor/fonts/**/*'])
		.pipe(gulp.dest(config.paths.build + 'fonts'))
});

gulp.task('compile-video', function() {
	return gulp.src([config.paths.src + 'video/**/*', config.paths.src + 'vendor/video/**/*'])
		.pipe(gulp.dest(config.paths.build + 'video'))
});

gulp.task('compile-audio', function() {
	return gulp.src([config.paths.src + 'audio/**/*', config.paths.src + 'vendor/audio/**/*'])
		.pipe(gulp.dest(config.paths.build + 'audio'))
});

/**
	Minify tasks.
*/

gulp.task('minify-css', function() {
	var minifyCSS = require('gulp-clean-css');

	return gulp.src(config.paths.build + 'css/**/*.css')
		.pipe(minifyCSS())
		.pipe(gulp.dest(config.paths.build + 'css'));
});

gulp.task('minify-js', function() {
	var minifyJS = require('gulp-minify');

	return gulp.src(config.paths.build + 'js/**/*.js')
		.pipe(minifyJS({noSource: true, ext: {min: '.js'}}))
		.pipe(gulp.dest(config.paths.build + 'js'));
});

/**
	Fingerprint assets and generate manifest file.
*/

gulp.task('manifest', function() {
	var rev    = require('gulp-rev');
	var revdel = require('gulp-rev-delete-original');

	return gulp.src(config.paths.build + '**/*')
		.pipe(rev())
		.pipe(revdel())
		.pipe(gulp.dest(function(file) {
			return file.base
		}))
		.pipe(rev.manifest(config.manifestPath, {base: config.manifestBase}))
		.pipe(gulp.dest(config.paths.build));
});

/**
	Clean build assets directory to prevent left-over files.
*/

gulp.task('clean', function() {
	var clean = require('gulp-clean');

	return gulp.src(config.paths.build, {read: false})
		.pipe(clean());
});

/**
	Wrapper tasks.
*/

// Compile task executes all compile and move tasks.
gulp.task('compile', gulp.parallel('compile-js', 'compile-css', 'compile-fonts', 'compile-img', 'compile-video', 'compile-audio'));

// Minify task executes all minify tasks.
gulp.task('minify', gulp.parallel('minify-js', 'minify-css'));

// Build task executes compile and move tasks,
// then minify tasks,
// then finally the fingerprint and manifest generation task.
gulp.task('build', gulp.series(function(cb) {
	// build can only be used for production mode.
	config.production = true
	cb()
}, 'clean', 'compile', 'minify', 'manifest'));

// Default task executes all compile and move tasks.
gulp.task('default', gulp.series('compile'));

// Watch task compiles all assets on start, then watches assets and html templates
// for change, recompiles them and signals livereload to reload the browser.
gulp.task('watch', gulp.series('compile', function() {
	var watch      = require('gulp-watch');
	var less       = require('gulp-less');
	var sass       = require('gulp-sass');
	var postcss    = require('gulp-postcss');
	var plumber    = require('gulp-plumber');
	var livereload = require('gulp-livereload');

	livereload.listen();
	
	es.merge(
		watch([config.paths.src + 'css/**/*.scss', config.paths.src + 'css/**/*.sass'])
			.pipe(plumber())
			.pipe(sass()),
		watch(config.paths.src + 'css/**/*.less', { ignoreInitial: true })
			.pipe(plumber())
			.pipe(less()),
		watch([config.paths.src + 'css/**/*.css', config.paths.src + 'vendor/css/**/*.css'])
	).pipe(postcss([require('autoprefixer', 'postcss-flexbug-fixes')]))
		.pipe(gulp.dest(config.paths.build + 'css'))
		.pipe(livereload())

	watch([config.paths.src + 'js/**/*.js', config.paths.src + 'vendor/js/**/*.js'])
		.pipe(plumber())
		.pipe(gulp.dest(config.paths.build + 'js'))
		.pipe(livereload())

	watch([config.paths.src + 'img/**/*', config.paths.src + 'vendor/img/**/*'])
		.pipe(plumber())
		.pipe(gulp.dest(config.paths.build + 'img'))
		.pipe(livereload())

	watch([config.paths.src + 'fonts/**/*', config.paths.src + 'vendor/fonts/**/*'])
		.pipe(plumber())
		.pipe(gulp.dest(config.paths.build + 'fonts'))
		.pipe(livereload())

	watch([config.paths.src + 'video/**/*', config.paths.src + 'vendor/video/**/*'])
		.pipe(plumber())
		.pipe(gulp.dest(config.paths.build + 'video'))
		.pipe(livereload())

	watch([config.paths.src + 'audio/**/*', config.paths.src + 'vendor/audio/**/*'])
		.pipe(plumber())
		.pipe(gulp.dest(config.paths.build + 'audio'))
		.pipe(livereload())

	// Watch html templates
	return watch(config.paths.templates)
		.pipe(livereload())
}));
