package sessions

import "net/http"

type cookieWriter interface {
	SetCookie(cookie *http.Cookie)
	GetCookie(name string) *http.Cookie
}

// sessionsResponseWriter is a wrapper of the ResponseWriter object used to
// buffer the cookies across session API calls, so that they can be written
// at the very end of the response workflow (opposed to written on every operation)
type sessionsResponseWriter struct {
	http.ResponseWriter
	wroteHeader  bool
	wroteCookies bool
	cookies      map[string]*http.Cookie
}

// newSessionsResponseWriter returns a new sessionsResponseWriter object with a pointer to
// the old ResponseWriter object
func newSessionsResponseWriter(w http.ResponseWriter) *sessionsResponseWriter {
	return &sessionsResponseWriter{ResponseWriter: w}
}

// Write calls the underlying ResponseWriter Write func
func (s *sessionsResponseWriter) Write(buf []byte) (int, error) {
	if !s.wroteHeader {
		s.WriteHeader(http.StatusOK)
	}
	return s.ResponseWriter.Write(buf)
}

// WriteHeader sets all cookies in the buffer on the underlying ResponseWriter's
// headers and calls the underlying ResponseWriter WriteHeader func
func (s *sessionsResponseWriter) WriteHeader(code int) {
	s.wroteHeader = true

	// Set all the cookies in the cookie buffer
	if !s.wroteCookies {
		s.wroteCookies = true
		for _, c := range s.cookies {
			http.SetCookie(s.ResponseWriter, c)
		}
	}

	s.ResponseWriter.WriteHeader(code)
}

func (s *sessionsResponseWriter) SetCookie(cookie *http.Cookie) {
	if s.cookies == nil {
		s.cookies = make(map[string]*http.Cookie)
	}

	if len(cookie.Name) == 0 {
		panic("cookie name cannot be empty")
	}

	s.cookies[cookie.Name] = cookie
}

func (s *sessionsResponseWriter) GetCookie(name string) *http.Cookie {
	return s.cookies[name]
}

// Middleware converts the ResponseWriter object to a SessionsResponse
// for buffering cookies across session API requests
func Middleware(next http.Handler) http.Handler {
	fn := func(w http.ResponseWriter, r *http.Request) {
		// Convert the response writer to a sessions response, so we can
		// use its cookie buffering and writing capabilities
		w = newSessionsResponseWriter(w)

		next.ServeHTTP(w, r)
	}

	return http.HandlerFunc(fn)
}

type resetExpiryMiddleware struct {
	resetter Resetter
}

// ResetMiddleware resets the users session expiry on each request
func (m resetExpiryMiddleware) ResetMiddleware(next http.Handler) http.Handler {
	fn := func(w http.ResponseWriter, r *http.Request) {
		err := m.resetter.ResetExpiry(w, r)
		if err != nil {
			panic(err)
		}

		next.ServeHTTP(w, r)
	}

	return http.HandlerFunc(fn)
}
