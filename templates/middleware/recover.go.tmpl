package middleware

import (
	"fmt"
	"net/http"

	"go.uber.org/zap"
)

// Recover middleware recovers panics that occur and gracefully logs their error
func (m Middleware) Recover(next http.Handler) http.Handler {
	fn := func(w http.ResponseWriter, r *http.Request) {
		defer func() {
			if err := recover(); err != nil {
				var protocol string
				if r.TLS == nil {
					protocol = "http"
				} else {
					protocol = "https"
				}
				
				{{if not .NoRequestID -}}
				var log *zap.Logger
				v := r.Context().Value(CtxLoggerKey)
				log, ok := v.(*zap.Logger)
				if !ok {
					panic("cannot get derived request id logger from context object")
				}
				{{- end}}

				// log all the fields
				{{if .NoRequestID -}}
				m.Log.Error(fmt.Sprintf("%s request error", protocol),
					zap.String("method", r.Method),
					zap.String("uri", r.RequestURI),
					zap.Bool("tls", r.TLS != nil),
					zap.String("protocol", r.Proto),
					zap.String("host", r.Host),
					zap.String("remote_addr", r.RemoteAddr),
					zap.String("error", fmt.Sprintf("%+v", err)),
				)
				{{- else -}}
				log.Error(fmt.Sprintf("%s request error", protocol),
					zap.String("method", r.Method),
					zap.String("uri", r.RequestURI),
					zap.Bool("tls", r.TLS != nil),
					zap.String("protocol", r.Proto),
					zap.String("host", r.Host),
					zap.String("remote_addr", r.RemoteAddr),
					zap.String("error", fmt.Sprintf("%+v", err)),
				)
				{{- end}}

				// Return a http 500 with the HTTP body of "Internal Server Error"
				http.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
			}
		}()

		next.ServeHTTP(w, r)
	}

	return http.HandlerFunc(fn)
}
