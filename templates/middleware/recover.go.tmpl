package middleware

import (
	"bytes"
	"fmt"
	"net/http"

	chimiddleware "github.com/pressly/chi/middleware"
	"github.com/uber-go/zap"
)

// Recover middleware recovers panics that occur and gracefully logs their error
func (m Middleware) Recover(next http.Handler) http.Handler {
	fn := func(w http.ResponseWriter, r *http.Request) {
		defer func() {
			if err := recover(); err != nil {
				buf := &bytes.Buffer{}
				requestID := chimiddleware.GetReqID(r.Context())

				if requestID != "" {
					fmt.Fprintf(buf, "[%s] ", requestID)
				}

				fmt.Fprintf(buf, `"%s `, r.Method)

				if r.TLS == nil {
					if _, err := buf.WriteString(`http`); err != nil {
						panic(err)
					}
				} else {
					if _, err := buf.WriteString(`https`); err != nil {
						panic(err)
					}
				}

				// Log the error message.
				fmt.Fprintf(buf, "://%s%s %s\" from %s", r.Host, r.RequestURI, r.Proto, r.RemoteAddr)
				m.Log.Panic(buf.String(), zap.String("error", err.(string)))

				// Return a http 500 with the HTTP body of "Internal Server Error"
				http.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
			}
		}()

		next.ServeHTTP(w, r)
	}

	return http.HandlerFunc(fn)
}
