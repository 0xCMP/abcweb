package app

import (
	"net/http"
	"os"
	"path"
	"path/filepath"
	"strings"

	"go.uber.org/zap"

	"{{.ImportPath}}/rendering"
	"{{.ImportPath}}/controllers"
	"{{.ImportPath}}/middleware"
	"github.com/volatiletech/abcmiddleware"
)

// InitRoutes initializes the webserver routing and controllers
func (s *State) InitRoutes() {
	m := middleware.Middleware{
		{{if .NoRequestID -}}
		Log:       s.Log,
		{{- end}}
		Render:    s.Render,
	}

	// The common state for each route handler
	root := controllers.Root{
		{{if .NoRequestID -}}
		Log:     s.Log,
		{{- end}}
		Render:  s.Render,
		{{if not .NoSessions -}}
		Session: s.Session,
		{{- end}}
	}
	
	// 404 route handler
	s.Router.NotFound(s.NotFound)


	main := controllers.Main{Root: root}
	s.Router.Get("/", m.Errors(main.Home))
}

// NotFound handler is called if the requested route or asset cannot be found.
// Since we cannot use Chi's FileServer because it does directory listings
// we have to serve static assets (public folder) from the NotFound handler.
//
// The NotFound handler works for assets in both /public and /public/assets
//
// The NotFound handler checks if the path has "/assets", and
// if found will attempt to retrieve the asset name from the compiled
// assets manifest file if in production mode. In development mode it will
// ignore manifest and attempt to serve the asset directly.
//
// For paths that aren't "/assets/X" it will attempt to serve the asset
// directly, if it exists.
//
// Assets that cannot be found will return 404.
func (s *State) NotFound(w http.ResponseWriter, r *http.Request) {
	{{if .NoRequestID -}}
	log := s.Log
	{{- else -}}
	// Get the Request ID scoped logger
	log := abcmiddleware.Log(r)
	{{- end}}

	reqURI := r.RequestURI
	// Ensure path is rooted at / to prevent path traversal
	if reqURI[0] != '/' {
		reqURI = "/" + reqURI
	}

	// Sanitize the path to prevent traversal exploits
	reqURI = path.Clean(reqURI)

	// the path to the asset file on disk
	var fpath string

	// Set path to asset in /assets, potentially contained in manifest
	if strings.HasPrefix(reqURI, "/assets/") {
		// Split on ? to discard any query parameters
		fname := strings.Split(strings.TrimPrefix(reqURI, "/assets/"), "?")[0]

		ok := false
		// Look up the gzip version of the asset in the manifest
		// if the browser accepts gzip encoding
		if strings.Contains(r.Header.Get("Accept-Encoding"), "gzip") {
			fpath, ok = rendering.AssetsManifest[fname+".gz"]
			if ok {
				w.Header().Set("Content-Encoding", "gzip")
			}
		}

		// If cannot find gzip version, attempt to serve regular version
		if !ok {
			fpath, ok = rendering.AssetsManifest[fname]
		}

		// If cannot find regular version in manifest, attempt to serve
		// using filename directly requested from browser
		if !ok {
			fpath = fname
		}
		fpath = filepath.Join(s.AppConfig.AssetsPublic, "assets", fpath)
	} else { // Set path to regular non-manifest asset
		// Split on ? to discard any query parameters
		fpath = filepath.Join(s.AppConfig.AssetsPublic, strings.Split(reqURI, "?")[0])
	}

	stat, err := os.Stat(fpath)
	// If file doesn't exist, or there's no error and the path is a dir, then 404
	if os.IsNotExist(err) || (err == nil && stat.IsDir()) {
		if err := s.Render.HTML(w, http.StatusNotFound, "errors/404", nil); err != nil {
			panic(err)
		}
		return
	} else if err != nil { // if not a file not exist error then http 500
		log.Fatal("failed to stat asset",
			zap.String("request_uri", r.RequestURI),
			zap.String("request_uri_sanitized", reqURI),
			zap.String("file_path", fpath),
			zap.Error(err),
		)
		if err := s.Render.HTML(w, http.StatusInternalServerError, "errors/500", nil); err != nil {
			panic(err)
		}
		return
	}

	fh, err := os.Open(fpath)
	if err != nil {
		log.Fatal("failed to open asset",
			zap.String("request_uri", r.RequestURI),
			zap.String("request_uri_sanitized", reqURI),
			zap.String("file_path", fpath),
			zap.Error(err),
		)
		if err := s.Render.HTML(w, http.StatusInternalServerError, "errors/500", nil); err != nil {
			panic(err)
		}
		return
	}

	// Serve the asset
	http.ServeContent(w, r, reqURI, stat.ModTime(), fh)

	fh.Close()
	return
}
