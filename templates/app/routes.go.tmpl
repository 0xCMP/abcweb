package app

import (
	"net/http"
	"os"
	"path"
	"path/filepath"
	"strings"

	"go.uber.org/zap"

	"{{.ImportPath}}/rendering"
	"{{.ImportPath}}/controllers"
	"{{.ImportPath}}/middleware"
	"github.com/volatiletech/abcmiddleware"
)

// InitRoutes initializes the webserver routing and controllers
func (s *State) InitRoutes() {
	m := middleware.Middleware{
		{{if .NoRequestID -}}
		Log:       s.Log,
		{{- end}}
		Render:    s.Render,
	}

	// The common state for each route handler
	root := controllers.Root{
		{{if .NoRequestID -}}
		Log:     s.Log,
		{{- end}}
		Render:  s.Render,
		{{if not .NoSessions -}}
		Session: s.Session,
		{{- end}}
	}
	
	// 404 route handler
	s.Router.NotFound(s.NotFound)

	// 405 route handler
	s.Router.MethodNotAllowed(s.MethodNotAllowed)

	main := controllers.Main{Root: root}
	s.Router.Get("/", m.Errors(main.Home))
}

// NotFound handler is called if the requested route or asset cannot be found.
// Since we cannot use Chi's FileServer because it does directory listings
// we have to serve static assets (public folder) from the NotFound handler.
//
// The NotFound handler works for assets in both /public and /public/assets
//
// The NotFound handler checks if the path has "/assets", and
// if found will attempt to retrieve the asset name from the compiled
// assets manifest file if in production mode. In development mode it will
// ignore manifest and attempt to serve the asset directly.
//
// For paths that aren't "/assets/X" it will attempt to serve the asset
// directly, if it exists.
//
// Assets that cannot be found will return 404.
func (s *State) NotFound(w http.ResponseWriter, r *http.Request) {
	{{if .NoRequestID -}}
	log := s.Log
	{{- else -}}
	// Get the Request ID scoped logger
	log := abcmiddleware.Log(r)
	{{- end}}

	reqPath := r.URL.Path
	// Ensure path is rooted at / to prevent path traversal
	if reqPath[0] != '/' {
		reqPath = "/" + reqPath
	}

	// Sanitize the path to prevent traversal exploits
	reqPath = path.Clean(reqPath)

	// the path to the asset file on disk
	var fpath string

	// Set path to asset in /assets, potentially contained in manifest
	if strings.HasPrefix(reqPath, "/assets/") {
		fname := strings.TrimPrefix(reqPath, "/assets/")

		ok := false
		// Look up the gzip version of the asset in the manifest
		// if the browser accepts gzip encoding
		if strings.Contains(r.Header.Get("Accept-Encoding"), "gzip") {
			fpath, ok = rendering.AssetsManifest[fname+".gz"]
			if ok {
				w.Header().Set("Content-Encoding", "gzip")
			}
		}

		// If cannot find gzip version, attempt to serve regular version
		if !ok {
			fpath, ok = rendering.AssetsManifest[fname]
		}

		// If cannot find regular version in manifest, attempt to serve
		// using filename directly requested from browser
		if !ok {
			fpath = fname
		}
		fpath = filepath.Join(s.AppConfig.PublicPath, "assets", fpath)
	} else { // Set path to regular non-manifest asset
		// Split on ? to discard any query parameters
		fpath = filepath.Join(s.AppConfig.PublicPath, reqPath)
	}

	stat, err := os.Stat(fpath)
	// If file doesn't exist, or there's no error and the path is a dir, then 404
	if os.IsNotExist(err) || (err == nil && stat.IsDir()) {
		if err := s.Render.HTML(w, http.StatusNotFound, "errors/404", nil); err != nil {
			panic(err)
		}
		return
	} else if err != nil { // if not a file not exist error then http 500
		log.Fatal("failed to stat asset",
			zap.String("request_uri", r.RequestURI),
			zap.String("file_path", fpath),
			zap.Error(err),
		)
		if err := s.Render.HTML(w, http.StatusInternalServerError, "errors/500", nil); err != nil {
			panic(err)
		}
		return
	}

	fh, err := os.Open(fpath)
	if err != nil {
		log.Fatal("failed to open asset",
			zap.String("request_uri", r.RequestURI),
			zap.String("file_path", fpath),
			zap.Error(err),
		)
		if err := s.Render.HTML(w, http.StatusInternalServerError, "errors/500", nil); err != nil {
			panic(err)
		}
		return
	}

	// Serve the asset
	http.ServeContent(w, r, reqPath, stat.ModTime(), fh)

	fh.Close()
	return
}

// MethodNotAllowed handler is called when someone attempts an operation
// against a route that does not support that operation, for example
// attempting a POST against a route that only supports a GET.
func (s *State) MethodNotAllowed(w http.ResponseWriter, r *http.Request) {
	{{if .NoRequestID -}}
	log := s.Log
	{{- else -}}
	// Get the Request ID scoped logger
	log := abcmiddleware.Log(r)
	{{- end}}

	log.Warn("method not allowed",
		zap.String("method", r.Method),
		zap.String("uri", r.RequestURI),
		zap.Bool("tls", r.TLS != nil),
		zap.String("protocol", r.Proto),
		zap.String("host", r.Host),
		zap.String("remote_addr", r.RemoteAddr),
	)

	if err := s.Render.HTML(w, http.StatusMethodNotAllowed, "errors/405", nil); err != nil {
		panic(err)
	}
}
