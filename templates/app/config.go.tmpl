package app

import (
	"time"

	"{{.ImportPath}}/config"
	"{{.ImportPath}}/db"
	{{if not .NoSessions -}}
	"github.com/volatiletech/abcsessions"
	{{- end}}
	"github.com/volatiletech/abcrender"
	"github.com/pressly/chi"
	"github.com/spf13/cobra"
	"go.uber.org/zap"
)

// State is the configuration state for the entire app.
// The controllers are passed variables from this object when initialized.
type State struct {
	AppConfig *config.AppConfig
	DBConfig	 *config.DBConfig
	Log		 *zap.Logger
	Router	 *chi.Mux
	Render	 abcrender.Renderer
	Root		 *cobra.Command
	{{if not .NoSessions -}}
	Session abcsessions.Overseer
	{{- end}}
}

// RegisterFlags registers the configuration flag defaults and help strings
func RegisterFlags(root *cobra.Command) {
	{{if not .NoLiveReload -}}
	root.Flags().BoolP("live-reload", "", false, "Enable or disable LiveReload")
	{{- end}}
	root.Flags().BoolP("prod-logger", "", true, "Use the production logger, JSON and log level warn")
	root.Flags().StringP("bind", "", ":80", `HTTP bind address, eg: ":80"`)
	root.Flags().StringP("tls-bind", "", "", `HTTPS bind address, eg: ":443"`)
	root.Flags().StringP("tls-cert-file", "", "", "TLS certificate file path")
	root.Flags().StringP("tls-key-file", "", "", "TLS key file path")
	root.Flags().DurationP("read-timeout", "", time.Second*10, "Maximum duration before timing out read of the request")
	root.Flags().DurationP("write-timeout", "", time.Second*15, "Maximum duration before timing out write of the response")
	root.Flags().DurationP("idle-timeout", "", time.Second*120, "Maximum duration before timing out idle keep-alive connection")

	// manifest.json is created as a part of the gulp production "build" task,
	// it maps fingerprinted asset names to regular asset names, for example:
	// {"js/main.css": "js/e2a3ff9-main.css"}.
	// This should only be set to true if doing asset fingerprinting.
	root.Flags().BoolP("assets-manifest", "", true, "Use manifest.json for mapping asset names to fingerprinted assets")

	// This should be used in development mode to prevent browser caching of assets
	root.Flags().BoolP("assets-no-cache", "", false, "Disable browsers caching asset files by setting response headers")
	// This should be used in development mode to avoid having to reload the
	// server on every template file modification.
	root.Flags().BoolP("render-recompile", "", false, "Enable recompilation of the template on each render")
	{{if not .NoSessions -}}
	// Defined in app/sessions.go -- Usually cookie storer for dev and disk storer for prod.
	root.Flags().BoolP("sessions-dev-storer", "", false, "Use the development mode sessions storer (defined in app/sessions.go)")
	{{- end}}
	root.Flags().BoolP("version", "", false, "Display the build version hash")
}

// InitConfig loads the AppConfig and DBConfig into the passed in app State
func (s *State) InitConfig() error {
	// Build app Config using env vars, config.toml file and cmd line flags
	appCfgViper, err := config.NewAppViper(s.Root.Flags())
	if err != nil {
		return errors.Wrap(err, "failed to load app config")
	}
	s.AppConfig = config.LoadAppConfig(appCfgViper)

	// Build db Config using env vars and database.toml cfg file
	dbCfgViper, err := config.NewDBViper(s.AppConfig.ActiveEnv)
	if err != nil {
		return errors.Wrap(err, "failed to load db config")
	}
	// if dbCfgViper is nil then don't load the DBConfig struct 
	// and presume we want to run the app without a database.
	if dbCfgViper != nil {
		s.DBConfig = config.LoadDBConfig(dbCfgViper)
		// Initialize the global database handle
		if err := db.InitDB(s.DBConfig); err != nil {
			return errors.Wrap(err, "failed to connect with global db handle")
		}
	}

	return nil
}
