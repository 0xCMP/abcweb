package app

import (
	"context"
	"crypto/tls"
	"fmt"
	"log"
	"net"
	"net/http"
	"os"
	"os/signal"

	"github.com/pkg/errors"
	"go.uber.org/zap"
)

// serverErrLogger allows us to use the zap.Logger as our http.Server ErrorLog
type serverErrLogger struct {
	log *zap.Logger
}

// Implement Write to log server errors using the zap logger
func (s serverErrLogger) Write(b []byte) (int, error) {
	s.log.Debug(string(b))
	return 0, nil
}

// StartServer starts the web server on the specified port
func (s *State) StartServer() error {
	var err error
	server := http.Server{
		ReadTimeout:  s.AppConfig.ReadTimeout,
		WriteTimeout: s.AppConfig.WriteTimeout,
		IdleTimeout:  s.AppConfig.IdleTimeout,
		ErrorLog:     log.New(serverErrLogger{s.Log}, "", 0),
		Handler:      s.Router,
	}

	server.TLSConfig = &tls.Config{
		// Causes servers to use Go's default ciphersuite preferences,
		// which are tuned to avoid attacks. Does nothing on clients.
		PreferServerCipherSuites: true,
		// Only use curves which have assembly implementations
		CurvePreferences: []tls.CurveID{
			tls.CurveP256,
			tls.X25519, // Go 1.8 only
		},
	}

	// subscribe to SIGINT signals
	quit := make(chan os.Signal)
	signal.Notify(quit, os.Interrupt)

	// Start server graceful shutdown goroutine
	go func() {
		<-quit
		log.Println("Shutting down server...")
		if err := server.Shutdown(context.Background()); err != nil {
			log.Fatalf("could not shutdown: %v", err)
		}
	}()

	if len(s.AppConfig.TLSBind) > 0 {
		s.Log.Info("starting https listener", zap.String("bind", s.AppConfig.TLSBind))
		server.Addr = s.AppConfig.TLSBind
		
		{{if not .NoHTTPRedirect -}}
		// Redirect http requests to https
		go s.Redirect()
		{{end -}}
		if err := server.ListenAndServeTLS(s.AppConfig.TLSCertFile, s.AppConfig.TLSKeyFile); err != nil {
			fmt.Printf("failed to ListenAndServeTLS: %v", err)
			return nil
		}
	} else {
		s.Log.Info("starting http listener", zap.String("bind", s.AppConfig.Bind))
		server.Addr = s.AppConfig.Bind
		if err := server.ListenAndServe(); err != nil {
			fmt.Printf("failed to ListenAndServe: %v", err)
			return nil
		}
	}

	return errors.Wrap(err, "failed to StartServer")
}

// Redirect listens on the non-https port, and redirects all requests to https
func (s *State) Redirect() {
	var err error

	// Get https port from TLS Bind
	_, httpsPort, err := net.SplitHostPort(s.AppConfig.TLSBind)
	if err != nil {
		s.Log.Fatal("failed to get port from tls bind", zap.Error(err))
	}

	s.Log.Info("starting http -> https redirect listener", zap.String("bind", s.AppConfig.Bind))

	server := http.Server{
		Addr:         s.AppConfig.Bind,
		// Do not set IdleTimeout, so Go uses ReadTimeout value.
		// IdleTimeout config value too high for redirect listener.
		ReadTimeout:  s.AppConfig.ReadTimeout,
		WriteTimeout: s.AppConfig.WriteTimeout,
		ErrorLog:     log.New(serverErrLogger{s.Log}, "", 0),
		Handler: http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			// Remove port if it exists so we can replace it with https port
			var httpHost string
			httpHost, _, err = net.SplitHostPort(r.Host)
			if err != nil {
				s.Log.Fatal("failed to get http host from request", zap.Error(err))
			}

			url := fmt.Sprintf("https://%s:%s%s", httpHost, httpsPort, r.RequestURI)
			http.Redirect(w, r, url, http.StatusMovedPermanently)
		}),
	}

	// Start permanent listener
	err = server.ListenAndServe()
	s.Log.Fatal("http redirect listener failed", zap.Error(err))
}
