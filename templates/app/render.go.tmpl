package app

import (
	"html/template"
	"bytes"
	"fmt"

	"{{.ImportPath}}/rendering"
	"{{.ImportPath}}/config"
	"github.com/unrolled/render"
)

// appHelpers is a map of the template helper functions.
// Assign the template helper funcs in here, example:
// "toUpper": strings.ToUpper
var appHelpers = template.FuncMap{
	"jsPath": func(s string) string { return "/assets/js/" + s },
	"cssPath": func(s string) string { return "/assets/css/" + s },
	"imgPath": func(s string) string { return "/assets/img/" + s },
	"videoPath": func(s string) string { return "/assets/video/" + s },
	"audioPath": func(s string) string { return "/assets/audio/" + s },
	"fontPath": func(s string) string { return "/assets/fonts/" + s },
	"assetPath": func(s string) string { return "/assets/" + s },
	
	// wrap full asset paths in include tags
	"cssTag": cssTag,
	"jsTag":  jsTag,

	{{if (and (eq .Bootstrap "regular") (not .NoBootstrapJS)) -}}
	// return all javascript include tags for all twitter bootstrap js plugins
	"jsBootstrap": jsBootstrap,
	{{- end}}
}

// InitRenderer initializes the renderer using the app configuration.
// If you need to use multiple renderers, you can add more Renderer
// variables to your State object and initialize them here.
func (s *State) InitRenderer() {
	// create an appConfig helper function for use within templates.
	// This helper func provides access to the s.AppConfig variables.
	appHelpers["appConfig"] = func() config.AppConfig {
		return *s.AppConfig
	}

	s.Render = &rendering.Render{
		Render: render.New(render.Options{
			Directory:     s.AppConfig.Templates,
			Layout:        "layouts/main",
			Extensions:    []string{".tmpl", ".html"},
			IsDevelopment: s.AppConfig.RenderRecompile,
			Funcs:         []template.FuncMap{appHelpers},

			// If you do not wish to handle Render errors yourself you can remove
			// this line. If this line is removed the Render library will
			// write the error.String() value to the HTTP response and
			// set the status code to 500. Note that removing this line can result
			// in leaking sensitive info through the error message strings.
			DisableHTTPErrorRendering: true,
		}),
	}
}

// cssTag wraps the asset path in a css link include tag
func cssTag(s string) template.HTML {
	return template.HTML(fmt.Sprintf("<link href=\"%s\" rel=\"stylesheet\">", s))
}

// jsTag wraps the asset path in a javascript script include tag
func jsTag(s string) template.HTML {
	return template.HTML(fmt.Sprintf("<script src=\"%s\"></script>", s))
}

{{if (and (eq .Bootstrap "regular") (not .NoBootstrapJS)) -}}
// jsBootstrap returns all javascript include tags for 
// all twitter bootstrap js plugins
func jsBootstrap() template.HTML {
	files := []string{
		"/assets/js/bootstrap/transition.js",
		"/assets/js/bootstrap/util.js",
		"/assets/js/bootstrap/alert.js",
		"/assets/js/bootstrap/button.js",
		"/assets/js/bootstrap/carousel.js",
		"/assets/js/bootstrap/collapse.js",
		"/assets/js/bootstrap/dropdown.js",
		"/assets/js/bootstrap/modal.js",
		"/assets/js/bootstrap/scrollspy.js",
		"/assets/js/bootstrap/tab.js",
		"/assets/js/bootstrap/tooltip.js",
		"/assets/js/bootstrap/popover.js",
	}

	buf := bytes.Buffer{}
	for _, file := range files {
		buf.WriteString(fmt.Sprintf("<script src=\"%s\"></script>\n", file))
	}
	return template.HTML(buf.String())
}
{{- end}}
