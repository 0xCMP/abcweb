package main

import (
	"{{.ImportPath}}/app"
	"{{.ImportPath}}/app/serving"
	"{{.ImportPath}}/config"
	"{{.ImportPath}}/db"
	"{{.ImportPath}}/rendering"
)

// rootSetup sets up the root cobra command
func rootSetup(state *app.State) {
	state.Root = &cobra.Command{
		Use:   "{{.AppName}} [flags]",
		Short: "{{.AppName}} web app server",
		RunE: func(cmd *cobra.Command, args []string) error {
			// Start https and/or http listeners (app/server.go)
			return state.StartServer()
		},
	}

	// Register the command-line configuration flags (app/config.go)
	app.RegisterFlags(state.Root)

	// The pre-run function will initialize the app.
	state.Root.PreRunE = func(cmd *cobra.Command, args []string) error {
		// Build app Config using env vars, config.toml file and cmd line flags (app/config.go)
		appCfgViper, err := config.NewAppViper(state.Root.Flags())
		if err != nil {
			return errors.Wrap(err, "failed to load app config")
		}
		state.AppConfig = config.LoadAppConfig(appCfgViper)

		// Build db Config using env vars and database.toml cfg file (app/config.go)
		dbCfgViper, err := config.NewDBViper(state.AppConfig.ActiveEnv)
		if err != nil {
			return errors.Wrap(err, "failed to load db config")
		}
		// if dbCfgViper is nil then don't load the DBConfig struct 
		// and presume we want to run the app without a database.
		if dbCfgViper != nil {
			state.DBConfig = config.LoadDBConfig(dbCfgViper)
			// Initialize the global database handle
			if err := db.InitDB(state.DBConfig); err != nil {
				return errors.Wrap(err, "failed to connect with global db handle")
			}
		}

		// Initialize the zap logger (app/logger.go)
		state.InitLogger()

		// Create a new router
		state.Router = chi.NewRouter()

		{{if not .NoSessions -}}
		// Configure the sessions overseer (app/sessions.go)
		state.InitSessions()
		{{- end}}

		// Cache the assets manifest.json file mappings (app/render.go)
		if state.AppConfig.AssetsManifest {
			rendering.AssetsManifest, err = rendering.GetManifest("public")
			if err != nil {
				return err
			}
		}

		// Configure the renderer (rendering/rendering.go)
		state.Render = rendering.InitRenderer(state.AppConfig, "templates")

		// Enable middleware for the router (app/middleware.go)
		state.InitMiddleware()

		// Initialize the routes with the renderer (app/routes.go)
		state.InitRoutes()
		return nil
	}
}

// migrateSetup sets up the migrate command and binds it to the root command
func migrateSetup(state *app.State) { 
	migrate := &cobra.Command{
		Use:   "migrate",
		Short: "Run your database migrations",
		RunE: func(cmd *cobra.Command, args []string) error {
			// Get the path of the web app binary
			path, err := os.Executable()
			if err != nil {
				return errors.Wrap(err, "unable to get web app binary path")
			}

			migrationsPath := filepath.Join(path, "migrations")

			found := false
			if _, err := os.Stat("migrations"); err == nil {
				found = true
			}

			// Restore the gobindata assets to disk if using bundled binary
			if !found {
				files, err := serving.AssetDir("migrations")
				if err != nil {
					return errors.Wrap(err, "unable to get migrations dir listing")
				}

				for _, file := range files {
					if err := serving.RestoreAsset("migrations", file); err != nil {
						return errors.Wrap(err, fmt.Sprintf("cannot restore asset %s", file))
					}
				}

				// Remove all migrations from disk once complete
				defer os.RemoveAll()
			}

			// Build app Config using env vars, config.toml file and cmd line flags (app/config.go)
			appCfgViper, err := config.NewAppViper(state.Root.Flags())
			if err != nil {
				return errors.Wrap(err, "failed to load app config")
			}
			state.AppConfig = config.LoadAppConfig(appCfgViper)

			// Build db Config using env vars and database.toml cfg file (app/config.go)
			dbCfgViper, err := config.NewDBViper(state.AppConfig.ActiveEnv)
			if err != nil || dbCfgViper == nil {
				return errors.Wrap(err, "failed to load db config")
			}
			state.DBConfig = config.LoadDBConfig(dbCfgViper)
	
			connStr := db.GetConnStr(state.DBConfig)
			count, err := mig.Up(state.DBConfig.DB, connStr, "migrations")
			if err != nil {
				return errors.Wrap(err, "call to mig up failed")
			}
			fmt.Printf("migrated %d database migrations\n", count)

			return nil
		},
	}
	
	state.Root.AddCommand(migrate)
}
