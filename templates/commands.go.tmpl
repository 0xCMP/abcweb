package main

import (
	{{if not .NoDB -}}
	"path/filepath"
	"fmt"
	"os"
	{{- end}}

	"{{.ImportPath}}/app"
	{{if not .NoDB -}}
	"{{.ImportPath}}/db"
	"{{.ImportPath}}/config"
	"github.com/pkg/errors"
	"github.com/volatiletech/mig"
	"github.com/spf13/viper"
	{{- end}}
	"{{.ImportPath}}/rendering"
	"github.com/pressly/chi"
	"github.com/spf13/cobra"
)

// rootSetup sets up the root cobra command
func rootSetup(state *app.State) {
	state.Root = &cobra.Command{
		Use:   "{{.AppName}} [flags]",
		Short: "{{.AppName}} web app server",
		RunE: func(cmd *cobra.Command, args []string) error {
			// Start https and/or http listeners (app/server.go)
			return state.StartServer()
		},
	}

	// Register the command-line configuration flags (app/config.go)
	app.RegisterFlags(state.Root)

	// The pre-run function will initialize the app.
	state.Root.PreRunE = func(cmd *cobra.Command, args []string) error {
		var err error

		// Initialize the AppConfig (app/config.go)
		if err := state.InitConfig(); err != nil {
			return err
		}

		// Initialize the zap logger (app/logger.go)
		state.InitLogger()

		// Create a new router
		state.Router = chi.NewRouter()

		{{if not .NoSessions -}}
		// Configure the sessions overseer (app/sessions.go)
		state.InitSessions()
		{{- end}}

		// Cache the assets manifest.json file mappings (app/render.go)
		if state.AppConfig.AssetsManifest {
			rendering.AssetsManifest, err = rendering.GetManifest(state.AppConfig.PublicPath)
			if err != nil {
				return err
			}
		}

		// Configure the renderer (rendering/rendering.go)
		state.Render = rendering.InitRenderer(state.AppConfig, "templates")

		// Enable middleware for the router (app/middleware.go)
		state.InitMiddleware()

		// Initialize the routes with the renderer (app/routes.go)
		state.InitRoutes()

		{{- if not .NoDB}}
		// Check if using the latest database migration if EnforceLatestMigration
		// is true, and if the config.toml has a database user set
		if state.AppConfig.EnforceMigration {
			migrated, version, err := db.IsMigrated(state.AppConfig.DB)
			if err != nil && err != db.ErrNoMigrations {
				return errors.Wrap(err, "failed to check if using latest migration")
			}
			if !migrated && err != db.ErrNoMigrations {
				return fmt.Errorf("database is out of sync with migrations, database version: %d", version)
			}
		}
		{{- end}}

		return nil
	}
}

{{- if not .NoDB}}
// migrateSetup sets up the migrate command and binds it to the root command
func migrateSetup(state *app.State) { 
	migrate := &cobra.Command{
		Use:   "migrate",
		Short: "Run your database migrations",
		RunE: func(cmd *cobra.Command, args []string) error {
			appViper, err := config.NewAppViper(cmd.Flags(), "config.toml")
			if err != nil {
				return errors.Wrap(err, "cannot create app config viper")
			}

			config := config.LoadAppConfig(appViper)

			if _, err := os.Stat(filepath.Join("db", "migrations")); err != nil {
				return errors.Wrap(err, "could not find migrations folder")
			}

			connStr, err := db.GetConnStr(config.DB)
			if err != nil {
				return errors.Wrap(err, "could not create connection string")
			}

			if viper.GetBool("down") {
				name, err := mig.Down(config.DB.DB, connStr, filepath.Join("db", "migrations"))
				if err != nil {
					return errors.Wrap(err, "call to mig down failed")
				}
				fmt.Printf("rolled back migration %q\n", name)
			} else {
				count, err := mig.Up(config.DB.DB, connStr, filepath.Join("db", "migrations"))
				if err != nil {
					return errors.Wrap(err, "call to mig up failed")
				}
				fmt.Printf("migrated %d database migrations\n", count)
			}

			return nil
		},
	}

	migrate.Flags().BoolP("down", "d", false, "Roll back the database migration version by one")
	migrate.Flags().StringP("env", "e", "prod", "The database config file environment to load")
	
	state.Root.AddCommand(migrate)
}
{{- end}}
