package controllers

import (
	"os"
	"fmt"
	"testing"

	"{{.ImportPath}}/config"
	"{{.ImportPath}}/db"
)

func TestMain(m *testing.M) {
	// Your custom TestMain pre-Run() code goes here

	r := testMainMigrations(m)

	// Your custom TestMain post-Run() code goes here

	os.Exit(r)
}

// testMainMigrations executes the database migrations for the test database
// defined in database.toml, runs the unit tests, and then downs the migrations.
// It returns a status code to be used with os.Exit(). Codes > 0 indicate error.
func testMainMigrations(m *testing.M) int {
	var skip bool

	// Load the database config
	v, err := config.NewDBViper("test") 
	if err != nil {
		fmt.Printf("failed to load database config for TestMain: %s\n", err)
		return 1	
	}
	dbCfg := config.LoadDBConfig(v)

	if len(dbCfg.User) == 0 {
		fmt.Println("No user defined in database.toml, skipping migrations.")
	} else {
		// Execute database migrations
		err = db.Setup(dbCfg)
		if err != nil {
			fmt.Printf("failed to execute database migrations for TestMain: %s\n", err)
			skip = true
		}
	}

	// Run the package tests
	var r int
	if !skip {
		r = m.Run()
	} else {
		fmt.Println("skipping unit tests due to migration error")
	}

	if len(dbCfg.User) != 0 {
		// Teardown the database migrations
		err = db.Teardown(dbCfg)
		if err != nil {
			fmt.Printf("failed to teardown database migrations for TestMain: %s\n", err)
			return 3	
		}
	}

	// If migrations failed, exit with error code
	if skip {
		return 2	
	}

	// Exit with return code of unit test run
	return r
}
